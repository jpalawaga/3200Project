//*****************************************************************************
// CPSC 3200          Professor: Howard Cheng
//                    Teaching Assistant: Darcy Best
// Written By: Camara Lerner
// Problem number: 
// Description: 
//*****************************************************************************

#include <string>
#include <iostream>
#include <cassert>
#include <vector>
#include <stack>
#include <cstdlib>
#include <sstream>
using namespace std;

int gcd(int a, int b)
{
  int r;

  /* unnecessary if a, b >= 0 */
  if (a < 0) {
    a = -a;
  }
  if (b < 0) {
    b = -b;
  }

  while (b) {
    r = a % b;
    a = b;
    b = r;
  }
  assert(a >= 0);
  return a;
}

int lcd(int a, int b) {
   return a * b / gcd(a,b);
}

class Rational {
public:
   friend Rational sumOR(vector<Rational> & a);
   friend Rational sumAND(vector<Rational> & a);
   Rational() {}
   Rational(const string &a);
   Rational(const int& a, const int& b) : top(a), bot(b) {}
   Rational& operator&(Rational & a);
   Rational& operator|(Rational & a);
   void print() const;
   string str() const;
private:
   Rational& reciprical();
   Rational& add(const Rational& a); 
   // hold the numerator and denominator
   int top, bot;
};

Rational::Rational(const string &a) {
   string::size_type mid = a.find('/');
   top = atoi(a.substr(0,mid).c_str());
   bot = atoi(a.substr(mid + 1, a.size() - mid - 1).c_str());
}

Rational& Rational::operator&(Rational & a) {
   return add(a);
}

Rational sumAND(vector<Rational> & a) {
   for(vector<Rational>::size_type i = 1; i < a.size(); ++i) {
      a[0].add(a[i]);
   }
   return a[0];
}

Rational& Rational::operator|(Rational & a) {
   reciprical();
   add(a.reciprical());
   int temp = top;
   top = bot;
   bot = temp;
   return *this;
}
Rational& Rational::reciprical() {
   int temp = top;
   top = bot;
   bot = temp;
   return *this;
}

Rational& Rational::add(const Rational& a) {
   int temp = bot;
   bot = lcd(top, a.top);
   top = a.bot*bot/a.top + temp*bot/top;
   return *this;
}

Rational sumOR(vector<Rational> & a) {
   if(a.size() <= 0) {
      return Rational(0, 0);
   }
   a[0].reciprical();
   for(vector<Rational>::size_type i = 1; i < a.size(); ++i) {
      a[0].add(a[i].reciprical());
   }
   a[0].reciprical();
   return a[0]; 
}

string Rational::str() const {
   ostringstream oss;
   oss << top << '/' << bot;
   return oss.str();
}
void Rational::print() const {
   cout << top << '/' << bot;
}

int main() {

   string line;
   while(getline(cin, line)) {
      stack< string > equation;
      if(line[0] != '(') {
	 cout << line << endl;
      } else {
	 Rational answer;
	 for(string::size_type i = 0; i < line.size(); ) {
	    if(line[i] == ' ') {
	       ++i;
	    } else if(line[i] == ')') {
	       // evaluate everthing on the stack that closes that bracket
	       // and push it back onto the stack
	       vector<Rational> mine;
	       string operation;
	       while(equation.top() != "(") {
		  if(equation.top() == "&" || equation.top() == "|") {
		     operation = equation.top();
		  } else {
		     // add the rational to the vector
		     mine.push_back(Rational(equation.top()));
		  }
		  equation.pop();
	       }
	       equation.pop();
	       // figure out result
	       if(operation == "&") {
		  answer = sumAND(mine);
	       } else if(operation == "|") {
		  answer = sumOR(mine);
	       } else {
		  cerr << "YOU FUCKED UP!" << endl;
	       }
	       answer.print();
	       cout << endl;
	       // push the result onto the mine(stack)
	       equation.push(mine[0].str());
	       ++i;
	    } else if((line[i] == '(') ||
		      (line[i] == '|') ||
		      (line[i] == '&')) {
	       // push onto the stack
	       equation.push(string(1,line[i]));
	       ++i;
	    } else {
	       int j = i;
	       // this is a rational
	       while(line[i] != ' ' || line[i] != ')') {
		  ++i;
	       }
	       equation.push(line.substr(j, i - j));
	    }
	 }
      }
   }
   return 0;
}
